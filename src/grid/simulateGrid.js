/**
 * Simulates a grid trading strategy over historical candle data.
 *
 * Each grid level alternates between BUY → SELL or SELL → BUY cycles,
 * dynamically adjusting order size per cycle and accounting for fees.
 * The simulation tracks profit, exposure, required capital, and optional
 * daily capital reports.
 *
 * @param {Array<Object>} grid
 * Grid definition, usually generated by buildGrid().
 * Each element must contain:
 *   - buy_price {number}  Buy trigger price
 *   - sell_price {number} Sell trigger price
 *
 * @param {Array<Array>} candles
 * Historical OHLCV candles in Binance kline format:
 * [ openTime, open, high, low, close, volume, ... ]
 *
 * @param {Object} [params]
 * Optional simulation parameters.
 *
 * @param {number} [params.baseUsdPerOrder=100]
 * Initial USD value allocated per grid level.
 *
 * @param {number} [params.feeRatePerSide=0.00075]
 * Trading fee per side, e.g. 0.075% if BNB discount
 *
 * @param {boolean} [params.enableLogs=false]
 * Enables verbose per-trade logging during simulation.
 *
 * @param {boolean} [params.dailyReport=true]
 * If true, emits one capital/exposure report per simulated day.
 *
 * @param {Function|null} [params.dailyReportFn=null]
 * Optional callback invoked once per day with the daily report object.
 * If not provided, reports are printed to stdout.
 *
 * @returns {{totalProfit: number, dailyReports: *[], cycles: number}} result
 *
 * @returns {number} result.cycles
 * Total number of completed grid cycles.
 *
 * @returns {number} result.totalProfit
 * Total net profit in USD after fees.
 *
 * @returns {Array<Object>} result.dailyReports
 * Optional daily capital reports, containing:
 *   - pending capital requirements
 *   - active (locked) capital
 *   - exposure converted at market price
 *   - cumulative profit and cycles
 */
export function simulateGrid(grid, candles, params = {}) {
  const {
    baseUsdPerOrder = 100,
    feeRatePerSide = 0.00015, // fee per side (ex: 0.00015 = 0.015%)
    enableLogs = false,
    dailyReport = true, // print once per day
    dailyReportFn = null, // optional: callback(reportObj)
  } = params;
  if (!candles?.length) {
    return { cycles: 0, totalProfit: 0, state: [], dailyReports: [] };
  }
  let cycles = 0;
  let totalProfit = 0;
  // First candle OPEN as reference
  const entryPrice = parseFloat(candles[0][1]);
  // Per-level state
  const state = grid.map((level, idx) => ({
    side: level.sell_price > entryPrice ? 'SELL' : 'BUY',
    active: false,
    lastOperation: false,
    usdPerOrder: baseUsdPerOrder,
    cycles: 0, // counted cycles (same as trade_profit rows)
    rawCycles: 0, // raw closes (every time a leg closes)
    profit: 0,
    index: idx,
    // Ledger while active (one leg executed, waiting for the opposite leg)
    openUsd: 0,
    openBtcQty: 0,
    openedAt: null,
    openedSide: null, // "BUY" | "SELL"
  }));
  const dailyReports = [];
  let lastReportDayKey = null;

  function makeDayKey(tsMs) {
    const d = new Date(tsMs);
    return `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(
      d.getUTCDate(),
    ).padStart(2, '0')}`;
  }

  function emitDailyReport(candle) {
    if (!dailyReport) return;
    const ts = candle[0];
    const close = parseFloat(candle[4]); // candle close (Binance klines)
    const dayKey = makeDayKey(ts);
    // Print only once per day
    if (dayKey === lastReportDayKey) return;
    lastReportDayKey = dayKey;
    // 1) Capital required for "armed" grid (pending legs)
    let pendingBuyCount = 0;
    let pendingSellCount = 0;
    let usdtNeededForPendingBuys = 0;
    let btcNeededForPendingSells = 0;
    // 2) Capital locked in already executed legs (active)
    let activeBuys = 0;
    let activeSells = 0;
    let usdtLockedInActiveBuys = 0;
    let btcLockedInActiveSells = 0;
    // Diagnostics
    let totalUsdPerOrderSum = 0;
    for (let i = 0; i < state.length; i++) {
      const s = state[i];
      const level = grid[i];
      totalUsdPerOrderSum += s.usdPerOrder;
      const usd = s.usdPerOrder;
      // Pending legs
      if (s.side === 'BUY') {
        pendingBuyCount++;
        usdtNeededForPendingBuys += usd;
      } else {
        pendingSellCount++;
        btcNeededForPendingSells += usd / level.sell_price;
      }
      // Active legs (already executed)
      if (s.active) {
        if (s.openedSide === 'BUY') {
          activeBuys++;
          usdtLockedInActiveBuys += s.openUsd;
        } else if (s.openedSide === 'SELL') {
          activeSells++;
          btcLockedInActiveSells += s.openBtcQty;
        }
      }
    }
    const pendingSellNotionalAtMarket = btcNeededForPendingSells * close;
    const totalNeededUsdEquivalent = usdtNeededForPendingBuys + pendingSellNotionalAtMarket;
    const activeSellNotionalAtMarket = btcLockedInActiveSells * close;
    const activeLockedUsdEquivalent = usdtLockedInActiveBuys + activeSellNotionalAtMarket;
    const report = {
      day: dayKey,
      priceClose: close,
      pendingBuyCount,
      pendingSellCount,
      usdtNeededForPendingBuys: +usdtNeededForPendingBuys.toFixed(2),
      btcNeededForPendingSells: +btcNeededForPendingSells.toFixed(8),
      pendingSellNotionalAtMarket: +pendingSellNotionalAtMarket.toFixed(2),
      totalNeededUsdEquivalent: +totalNeededUsdEquivalent.toFixed(2),
      activeBuys,
      activeSells,
      usdtLockedInActiveBuys: +usdtLockedInActiveBuys.toFixed(2),
      btcLockedInActiveSells: +btcLockedInActiveSells.toFixed(8),
      activeLockedUsdEquivalent: +activeLockedUsdEquivalent.toFixed(2),
      totalUsdPerOrderSum: +totalUsdPerOrderSum.toFixed(2),
      cycles,
      totalProfit: +totalProfit.toFixed(2),
    };
    dailyReports.push(report);
    if (typeof dailyReportFn === 'function') {
      dailyReportFn(report);
    } else {
      console.log(
        `[${report.day}] close=${report.priceClose}` +
        ` | pending BUY=${report.pendingBuyCount} (USDT=${report.usdtNeededForPendingBuys})` +
        ` | pending SELL=${report.pendingSellCount} (BTC=${report.btcNeededForPendingSells}, notional@market=${report.pendingSellNotionalAtMarket})` +
        ` | totalNeeded≈${report.totalNeededUsdEquivalent}` +
        ` | cycles=${report.cycles} | profit=${report.totalProfit}`,
      );
    }
  }

  // Main loop
  for (const candle of candles) {
    emitDailyReport(candle);
    const time = new Date(candle[0]).toISOString();
    const high = parseFloat(candle[2]);
    const low = parseFloat(candle[3]);
    for (let i = 0; i < grid.length; i++) {
      const level = grid[i];
      const s = state[i];
      const { touchesBuy, touchesSell } = candleTouchesLevel(candle, level);
      // BUY side
      if (s.side === 'BUY') {
        // Open BUY leg
        if (!s.active && touchesBuy) {
          const usd = s.usdPerOrder;
          s.active = true;
          s.openUsd = usd;
          s.openBtcQty = usd / level.buy_price;
          s.openedAt = candle[0];
          s.openedSide = 'BUY';
          if (enableLogs) {
            console.log(
              `(${time}) Level ${i} OPEN (BUY) | buy=${level.buy_price} | usd=${usd.toFixed(
                2,
              )} | qty=${s.openBtcQty.toFixed(8)} | high=${high} low=${low}`,
            );
          }
          continue;
        }
        // Close BUY→SELL cycle
        if (s.active && touchesSell) {
          const usd = s.openUsd || s.usdPerOrder;
          const gross = usd * (level.sell_price / level.buy_price - 1);
          const notionalBuyUsd = usd;
          const notionalSellUsd = usd * (level.sell_price / level.buy_price);
          const fees = notionalBuyUsd * feeRatePerSide + notionalSellUsd * feeRatePerSide;
          const netProfit = gross - fees;
          s.side = 'SELL';
          s.active = false;
          const shouldCount = s.lastOperation === true;
          s.lastOperation = !s.lastOperation;
          s.rawCycles++;
          if (shouldCount) {
            s.cycles++;
            cycles++;
            s.profit += netProfit;
            totalProfit += netProfit;
          }
          // Clear position
          s.openUsd = 0;
          s.openBtcQty = 0;
          s.openedAt = null;
          s.openedSide = null;
          if (enableLogs) {
            console.log(
              `(${time}) Level ${i} CLOSE (BUY→SELL) | sell=${level.sell_price} | usd=${usd.toFixed(
                2,
              )} | profit=${netProfit.toFixed(4)}`,
            );
          }
          continue;
        }
      }
      // SELL side
      if (s.side === 'SELL') {
        // Open SELL leg
        if (!s.active && touchesSell) {
          const usd = s.usdPerOrder;
          s.active = true;
          s.openUsd = usd;
          s.openBtcQty = usd / level.sell_price;
          s.openedAt = candle[0];
          s.openedSide = 'SELL';
          if (enableLogs) {
            console.log(
              `(${time}) Level ${i} OPEN (SELL) | sell=${level.sell_price} | usd=${usd.toFixed(
                2,
              )} | qty=${s.openBtcQty.toFixed(8)} | high=${high} low=${low}`,
            );
          }
          continue;
        }
        // Close SELL→BUY cycle
        if (s.active && touchesBuy) {
          const usd = s.openUsd || s.usdPerOrder;
          const gross = usd * (1 - level.buy_price / level.sell_price);
          const notionalSellUsd = usd;
          const notionalBuyUsd = usd * (level.buy_price / level.sell_price);
          const fees = notionalSellUsd * feeRatePerSide + notionalBuyUsd * feeRatePerSide;
          const netProfit = gross - fees;
          s.side = 'BUY';
          s.active = false;
          const shouldCount = s.lastOperation === true;
          s.lastOperation = !s.lastOperation;
          s.rawCycles++;
          if (shouldCount) {
            s.cycles++;
            cycles++;
            s.profit += netProfit;
            totalProfit += netProfit;
          }
          // Clear position
          s.openUsd = 0;
          s.openBtcQty = 0;
          s.openedAt = null;
          s.openedSide = null;
          if (enableLogs) {
            console.log(
              `(${time}) Level ${i} CLOSE (SELL→BUY) | buy=${level.buy_price} | usd=${usd.toFixed(
                2,
              )} | profit=${netProfit.toFixed(4)}`,
            );
          }
          continue;
        }
      }
    }
  }
  // Final sizing summary
  const sumUsdPerOrder = state.reduce((acc, s) => acc + s.usdPerOrder, 0);
  if (enableLogs) {
    const gridLevels = grid.length;
    const allocatedUsd = sumUsdPerOrder;
    const pnlUsd = totalProfit;
    const pnlPct = allocatedUsd > 0 ? (pnlUsd / allocatedUsd) * 100 : 0;
    const avgPnlPerCycle = cycles > 0 ? pnlUsd / cycles : 0;

    // Period stats (based on candle timestamps)
    const startTs = candles[0]?.[0];
    const endTs = candles[candles.length - 1]?.[0];
    const ms = (endTs ?? 0) - (startTs ?? 0);
    const days = ms > 0 ? Math.max(1, ms / (1000 * 60 * 60 * 24)) : 1;

    const pnlPerDayUsd = pnlUsd / days;
    const pnlPerWeekUsd = pnlPerDayUsd * 7;
    const pnlPerMonthUsd = pnlPerDayUsd * 30;
    const pnlPerYearUsd = pnlPerDayUsd * 365;

    const pnlPerDayPct = allocatedUsd > 0 ? (pnlPerDayUsd / allocatedUsd) * 100 : 0;
    const pnlPerWeekPct = allocatedUsd > 0 ? (pnlPerWeekUsd / allocatedUsd) * 100 : 0;
    const pnlPerMonthPct = allocatedUsd > 0 ? (pnlPerMonthUsd / allocatedUsd) * 100 : 0;
    const pnlPerYearPct = allocatedUsd > 0 ? (pnlPerYearUsd / allocatedUsd) * 100 : 0;
    const startDateStr = new Date(candles[0][0]).toISOString().split('T')[0];
    const endDateStr = new Date(candles[candles.length - 1][0]).toISOString().split('T')[0];

    console.log('BACKTEST SUMMARY');
    console.log('=========================================');
    console.log(`Grid levels: ${gridLevels}`);
    console.log(`Period: ${startDateStr} → ${endDateStr}`);
    console.log(`Base USD per level: $${baseUsdPerOrder.toFixed(2)}`);
    console.log(`Total allocated notional: $${allocatedUsd.toFixed(2)}`);
    console.log(`Period: ${days.toFixed(2)} days`);
    console.log(`Counted cycles: ${cycles}`);
    console.log(`PnL: $${pnlUsd.toFixed(2)} (${pnlPct.toFixed(2)}%)`);
    console.log(`Avg PnL per cycle: $${avgPnlPerCycle.toFixed(4)}`);
    console.log(`Fee rate per side: ${(feeRatePerSide * 100).toFixed(4)}%`);
    console.log('--- Projections (assuming same performance rate) ---');
    console.log(`Per day:   $${pnlPerDayUsd.toFixed(2)} (${pnlPerDayPct.toFixed(2)}%)`);
    console.log(`Per week:  $${pnlPerWeekUsd.toFixed(2)} (${pnlPerWeekPct.toFixed(2)}%)`);
    console.log(`Per month: $${pnlPerMonthUsd.toFixed(2)} (${pnlPerMonthPct.toFixed(2)}%)`);
    console.log(`Per year:  $${pnlPerYearUsd.toFixed(2)} (${pnlPerYearPct.toFixed(2)}%)`);
    console.log('=========================================');
  }

  // Force last day report (if it didn't print yet)
  emitDailyReport(candles[candles.length - 1]);
  return { cycles, totalProfit };
}


function candleTouchesLevel(candle, level) {
  const high = parseFloat(candle[2]);
  const low = parseFloat(candle[3]);

  const touchesBuy = (low <= level.buy_price);
  const touchesSell = (level.sell_price <= high);

  return { touchesBuy, touchesSell };
}